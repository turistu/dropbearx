#! /bin/sh
umask 066
unset IFS
status=0
readfile() {
	t=$(cat "$2"; echo x); t=${t%x}; eval "$1=\$t"
}
check(){
	printf '\033[1mcheck'; printf ' %s' "$@"; printf '\033[m\n'
	pat=$(printf "$1"); shift
	case $# in 1) eval "$1" &&:;; *) "$@" &&:;; esac >out 2>err
	exit=$?
	readfile out out
	readfile err err
	res=$exit:$out:$err
	case $res in
	$pat)	printf '   \033[1;32mOK\033[m\n';;
	*)	
		printf '   \033[1;31mFAIL\033[m\n   <%s> !~ <%s>\n\n' \
			"$(printf %s "$res" | cat -v)" \
			"$(printf %s "$pat" | cat -v)"
		status=1;;
	esac
}
dscp_h(){ multi/scp -i key -o UserKnownHostsFile=known_hosts "$@"; }
dssh(){ "$s/dbclient" -i key "$@"; }
dssh_h(){ dssh -o UserKnownHostsFile=known_hosts "$@"; }

stuff=1
hcheck(){
	case $1 in
	%)	t=hcheck$((stuff=$stuff+1)); p=0:$t: ;;
	*:*)	p=$1; t=${p#*:}; t=${t%:*};;
	*)	t=$1; p=0:$t: ;;
	esac
	shift
	check "$p" dssh_h "$@" localhost printf "$t"
}

##################################################################
set -e
tmpdir=$(mktemp -d)
onexit(){
	set +e
	for p in dropbear dropbearmulti dbclient sleep env
		do pkill -s 0 "$p"; done
	wait
	rm -fr "$tmpdir"
}
trap onexit EXIT INT TERM
case $1 in
-s)	do_shell=1; shift;;
*)	do_shell=0;;
esac
s=${1:-.}
case $s in /*);; *) s=$(pwd)/$s;; esac

cd "$tmpdir"
HOME=$tmpdir
"$s/dropbearkey" -t ed25519 -f key
"$s/dropbearkey" -y -f key > key.pub+
grep ^ssh key.pub+ > key.pub
rm key.pub+
set $(cat key.pub)
echo "localhost $1 $2" > known_hosts

port=2222

mkdir multi
for f in scp dropbear dbclient; do ln -s "$s/dropbearmulti" "multi/$f"; done

multi/dropbear -mqF -p $port -r key -A key.pub &

if [ $do_shell = 1 ]; then
	BDIR=$s PORT=$port sh
	exit
fi

##################################################################
sleep .2
{ env sleep 20; pkill -s 0 dbclient; } &

exec </dev/null
echo ===========

check '0:test:*key accepted unconditionally*' \
	dssh -y -p "$port" localhost printf test
check 0:test: \
	dssh_h -J "$s/dropbear -iFE -r key -A key.pub" localhost printf test
check '0:test\r\n:' \
	dssh_h -t -p "$port" localhost echo test
check '0:foobar\n:' \
	dssh_h -p "$port" localhost '{ sleep .5; echo bar; } & printf foo'

hcheck % -p "$port"

dssh_h \
	-R 8888:localhost:$port \
	-L 7777:localhost:$port \
	-R 0:localhost:$port \
	-L 0:localhost:$port \
	-p "$port" -N localhost 2>&1 | tee stderr &
sleep .5
#eval $(awk '/Allocated port [0-9]+ for (local|remote)/{print $6"_port="$4}' stderr)
# shitty (older) android doesn't even have a working sed or awk
set -- $(grep 'Allocated port [0-9]* for [lr][oe]' stderr | cut -d" " -f4,6)
eval "${2}_port=$1; ${4}_port=$3"

hcheck '1::*Remote TCP forward request failed*' \
	-p $port -o ExitOnForwardFailure=yes -R 8:localhost:$port
hcheck % -p 7777
hcheck % -p 8888
hcheck % -p $remote_port
hcheck % -p $local_port

echo first > local.txt
! "$s/dropbearmulti" scp -i key -o UserKnownHostsFile=known_hosts \
	-P $port local.txt localhost:$tmpdir/remote.txt
check 0:: cmp local.txt remote.txt

echo second > local.txt
! multi/scp -i key -o UserKnownHostsFile=known_hosts \
	-P $port local.txt localhost:$tmpdir/remote.txt
check 0:: cmp local.txt remote.txt

if script -qc true /dev/null 2>/dev/null; then
	dssh_pty(){ script -qc "$s/dbclient -i key -o UserKnownHostsFile=known_hosts $*" /dev/null; }
	check '0:echo test\r\n*test\r\n*test\r\n*:' \
		'echo echo test | dssh_pty -p $port localhost'
	check '0:1\r\ntest\r\n:' \
		'echo 1 | dssh_pty -p $port localhost echo test'

	port=2223
else
	echo fixme: do the local tty tests on "$(uname)"
fi
if unshare 2>/dev/null -Ucm --keep-caps sh -c "
	mount -B /dev/null /dev/ptmx
	$s/dropbear -mqF -p $port -r key -A key.pub &
	sleep .2
	"
then
	port=2223
	check '0:test\n:*PTY allocation request failed*' \
		dssh_h -t -p $port localhost echo test
	check '0:test\r\n*PTY allocation request failed*:' \
		'echo test | dssh_pty -p $port localhost'
else
	echo no unshare, skipping the no /dev/ptmx part
fi
##################################################################

echo STATUS $status
exit $status
