#! /bin/sh
umask 066
unset IFS
status=0
readfile() {
	t=$(cat "$2"; echo x); t=${t%x}; eval "$1=\$t"
}
showcmd() {
	cmd=$1; shift
	printf '\033[1m%s' "$cmd"; printf ' %s' "$@"; printf '\033[m\n'
}
v(){
	showcmd "$@"; "$@"
}
check(){
	showcmd check "$@"
	pat=$(printf ":$1:"); shift
	case $# in 1) eval "$1" &&:;; *) "$@" &&:;; esac >out 2>err
	exit=$?
	readfile out out
	readfile err err
	res=:$exit:$out:$err:
	case $res in
	$pat)	printf '   \033[1;32mOK\033[m\n';;
	*)	
		printf '   \033[1;31mFAIL\033[m\n   <%s> !~\n   <%s>\n\n' \
			"$(printf %s "$res" | cat -v)" \
			"$(printf %s "$pat" | cat -v)"
		status=1;;
	esac
}
if [ "$NO_PKILL_G" ]; then
	xkill(){ pkill -s 0 "$@"; }
else
	xkill(){ pkill -g0 "$@"; }
fi
dssh(){ "$s/dbclient" "$@"; }
stuff=1
hcheck(){
	case $1 in
	%)	t=hcheck$((stuff=$stuff+1)); p=0:$t: ;;
	*:*)	p=$1; t=${p#*:}; t=${t%:*};;
	*)	t=$1; p=0:$t: ;;
	esac
	shift
	check "$p" dssh $H$I "$@" localhost printf "$t"
}

##################################################################
set -e
tmpdir=$(mktemp -d)
onexit(){
	set +e
	for p in dropbear dropbearmulti dbclient sleep env
		do xkill "$p"; done
	wait
	if [ "$do_keep" ]; then echo see "$tmpdir"
	else rm -fr "$tmpdir"
	fi
}
trap onexit EXIT INT TERM
do_shell=0
do_keep=
log_opt=-E
while :; do
	case $1 in
	-q)	log_opt=$1;;
	-s)	do_shell=1;;
	-k)	do_keep=1;;
	*)	break;;
	esac
	shift
done
s=${1:-.}
case $s in /*);; *) s=$(pwd)/$s;; esac

cd "$tmpdir"
HOME=$tmpdir

mk_key(){
	"$s/dropbearkey" -t ed25519 -f "$1" &&
	"$s/dropbearkey" -y -f "$1" > "$1.pub+" &&
	grep ^ssh "$1.pub+" > "$1.pub"
	rm "$1".pub+
}
mk_key key
mk_key key1
set $(cat key.pub)
echo "localhost $1 $2" >> known_hosts
echo "127.0.0.1 $1 $2" >> known_hosts
echo "127.0.0.2 $1 $2" >> known_hosts
echo "127.0.0.3 $1 $2" >> known_hosts

{
	printf 'permitopen="127.0.0.2:7777" '
	cat key1.pub
	cat key.pub
} > auth_keys

port=2222
I=" -i key"
P=" -p $port"
H=" -o UserKnownHostsFile=known_hosts"

mkdir multi
for f in scp dropbear dbclient; do ln -s "$s/dropbearmulti" "multi/$f"; done

v multi/dropbear "$log_opt" -a -mF -p $port -r key -A auth_keys &

if [ $do_shell = 1 ]; then
	BDIR=$s PORT=$port sh
	exit
fi

##################################################################
sleep .2
{ env sleep 20; xkill dbclient; } &

exec </dev/null
echo ===========

check '0:test:*key accepted unconditionally*' \
	dssh $I -y -p "$port" localhost printf test
check '0:test\r\n:' \
	dssh $H$I -t -p "$port" localhost echo test
check '0:foobar\n:' \
	dssh $H$I -p "$port" localhost '{ sleep .5; echo bar; } & printf foo'
check '0:127.0.0.2 9999 127.0.0.3 2222\n:127.0.0.2 9999 2222\n' \
	dssh $H$I -p "$port" -b 127.0.0.2:9999 127.0.0.3 \
		'echo $SSH_CONNECTION; echo >&2 $SSH_CLIENT'

hcheck % -p "$port"

v dssh $H$P$I \
	-R 8888:localhost:$port \
	-L 7777:localhost:$port \
	-R 0:localhost:$port \
	-L 0:localhost:$port \
	-p "$port" -N localhost 2>&1 | tee stderr &
sleep .5
#eval $(awk '/Allocated port [0-9]+ for (local|remote)/{print $6"_port="$4}' stderr)
# shitty (older) android doesn't even have a working sed or awk
set -- $(grep 'Allocated port [0-9]* for [lr][oe]' stderr | cut -d" " -f4,6)
eval "${2}_port=$1; ${4}_port=$3"

hcheck '1::*Remote TCP forward request failed*' \
	-p $port -o ExitOnForwardFailure=yes -R 8:localhost:$port
hcheck % -p 7777
hcheck % -p 8888
hcheck % -p $remote_port
hcheck % -p $local_port

##################################################################

echo first > local.txt
! "$s/dropbearmulti" scp -i key -o UserKnownHostsFile=known_hosts \
	-P $port local.txt localhost:$tmpdir/remote.txt
check 0:: cmp local.txt remote.txt

echo second > local.txt
! multi/scp -i key -o UserKnownHostsFile=known_hosts \
	-P $port local.txt localhost:$tmpdir/remote.txt
check 0:: cmp local.txt remote.txt

##################################################################

check 0:test: \
	dssh $H$I -J "$s/dropbear -iFq -r key -A key.pub" localhost printf test
dssh_pty(){
	dssh $H$I -t -J "$s/dropbear -iFq -r key -A key.pub" localhost \
		"cd $tmpdir && { $s/dbclient -i key -o UserKnownHostsFile=known_hosts $*; }"
}

check '0:1\r\ntest\r\n:' \
	'echo 1 | dssh_pty -p $port localhost echo test'
check '0:echo test\r\n*test\r\n*test\r\n*:' \
	'{ printf "echo test\rexit\r"; } | dssh_pty -p $port localhost'

##################################################################

port=2223
if unshare 2>/dev/null -Ucm --keep-caps sh -c "
	mount -B /dev/null /dev/ptmx
	$s/dropbear -mqF -p $port -r key -A key.pub &
	sleep .2
	"
then
	check '0:test\n:*PTY allocation request failed*' \
		dssh $H$I -t -p $port localhost echo test
	check '0:true\r\n*PTY allocation request failed*:' \
		'printf "true\rexit\r" | dssh_pty -p $port localhost'
else
	echo >&2 no unshare, skipping the no /dev/ptmx part
fi
##################################################################

echo STATUS $status
exit $status
